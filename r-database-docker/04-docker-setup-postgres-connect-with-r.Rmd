# Docker, Postgres, and R

We always load the tidyverse and some other packages, but don't show it unless we are using packages other than `tidyverse`, `DBI`, `RPostgres`, and `glue`.
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(DBI)
library(RPostgres)
library(glue)
```
## Verify that Docker running

Docker commands can be run from a terminal (e.g., the Rstudio Terminal pane) or with a `system()` command.  In this tutorial, we use `system2()` so that all the output that is created externally is shown.  Note that `system2` calls are divided into several parts:

1. The program that you are sending a command to.
2. The parameters or commands that are being sent
3. `stdout = TRUE, stderr = TRUE` are two parameters that are standard in this book, so that the comand's full output is shown in the book.

The `docker version` command returns the details about the docker daemon that is running on your computer.
```{r}
system2("docker", "version", stdout = TRUE, stderr = TRUE)
```

The convention we use in this book is to assemble a command with `paste0` so that the parts of the command can be specified separately.  This chunk just constructs the command, but does not execute.  If you have problems, you can copy the command and execute in your terminal session.

chunk the following... 
```{r, eval=TRUE, echo=TRUE}
docker_cmd <- glue(
  "run ",      # Run is the Docker command.  Everything that follows are `run` parameters.
  "--detach ", # (or `-d`) tells Docker to disconnect from the terminal / program issuing the command
  "--name cattle ",       # tells Docker to give the container a name: `cattle`
  "--publish 5432:5432 ", # tells Docker to expose the Postgres port 5432 to the local network with 5432
  " postgres:10"  # tells Docker the image that is to be run (after downloading if necessary)
)
docker_cmd


# Naming containers `cattle` for throw-aways and `pet` for ones we treasure and keep around.  :-)
```

Remove `cattle` if it exists.

Submit the command constructed above:
```{r, eval=TRUE, echo=TRUE}
system2("docker", docker_cmd, stdout = TRUE, stderr = TRUE)
```
Possible errors here: if docker isn't ready, you'll see errors.

Docker returns a long string of numbers.  If you are running this command for the first time, Docker is downloading the Postgres image and it takes a bit of time.

The following comand shows that `postgres:10` is still running:
```{r, eval=TRUE, echo=TRUE}
system2("docker", "ps", stdout = TRUE, stderr = TRUE)

```
## Put the database password in an environment file
The goal is to put the password in a file that will **not** be committed in your source code repository. The your code can reference the name of the variable, but the value of that variable will not appear in open text in your source code.

We have chosen to call the file `dev_environment.csv` in the current working directory where you are executing this script. That file name appears in the `.gitignore` file, so that you will not accidentally commit it. We are going to create that file now.

You will be prompted for the database password. By default, a postgres database defines a database user named `postgres`, whose password is `postgres`. If you have changed the password or created a new user with a different password, then enter those new values when prompted. Otherwise, enter `postgres` and `postgres` at the two prompts.
```{r}
DB_USERNAME <- trimws(readline(prompt = "username: "), which = "both")
DB_PASSWORD <- getPass::getPass(msg = "password: ")
environment_variables = data.frame(
  variable = c("username", "password"),
  value = c(DB_USERNAME, DB_PASSWORD),
  stringsAsFactors = FALSE)
write.csv(environment_variables, "./dev_environment.csv", row.names = FALSE)
```
## Connect, read and write to Postgres from R
Create a connection to Postgres after waiting 3 seconds so that Docker has time to do its thing.
```{r}
Sys.sleep(3)

con <- DBI::dbConnect(
  RPostgres::Postgres(),
  host = "localhost",
  port = "5432",
  user = dplyr::filter(environment_variables, variable == "username")[, "value"],
  password = dplyr::filter(environment_variables, variable == "password")[, "value"])
```

Show that you can connect but that Postgres database doesn't contain any tables:

```{r}
dbListTables(con)
```

Write `mtcars` to Postgres
```{r}
dbWriteTable(con, "mtcars", mtcars)
```

List the tables in the Postgres database to show that `mtcars` is now there:

```{r}
dbListTables(con)

# list the fields in mtcars:
dbListFields(con, "mtcars")
```

Download the table from the DBMS to a local data frame:
```{r}
mtcars_df <- tbl(con, "mtcars")

# Show a few rows:
knitr::kable(head(mtcars_df))
```

## Clean up

Afterwards, always disconnect from the DBMS, stop the docker container and (optionally) remove it.
```{r}
dbDisconnect(con)

# tell Docker to stop the container:
system2("docker", "stop cattle", stdout = TRUE, stderr = TRUE)

# tell Docker to remove the container from it's library of active containers:
system2("docker", "rm cattle", stdout = TRUE, stderr = TRUE)
```

If we `stop` the docker container but don't remove it (with the `rm cattle` command), the container will persist and we can start it up again later with `start cattle`.  In that case, `mtcars` would still be there and we could retrieve it from R again.  Since we have now removed the `cattle` container, the whole database has been deleted.  (There are enough copies of `mtcars` in the world, so no great loss.)
