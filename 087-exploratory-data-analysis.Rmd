# Exploratory Data Analysis {#chapter_exploratory-data-analysis}

> The previous chapter enabled us to get started with the AdventureWorks database. We saw how to list tables and fields to get an overview of the type of data contained in the database. This chapter proceeds through a hypothetical scenario where we dig deeper to answer specific business questions.

## Setup

The following packages are used in this chapter:
```{r package list, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(DBI)
library(RPostgres)
library(dplyr)
library(dbplyr)
library(lubridate)
library(forcats)
library(ggplot2)
library(sqlpetr)
require(knitr)
library(bookdown)
```

Assume that the Docker container with PostgreSQL and the adventureworks database are ready to go. If not go back to [Chapter 6][#chapter_setup-adventureworks-db]
```{r check on adventureworks}
sqlpetr::sp_docker_start("adventureworks")
```

## Number of Orders
Suppose we are developers who use the corporate database. We often receive requests from executives who have some burning question as they try to understand and improve the company's processes. Today is no exception. AdventureWorks has just hired a new Vice President of Sales, Sally Seashells. She sends us an email, asking for a report of sales volumes for the past 4 years.

Let's find the quantity of sales orders, which we can count from the SalesOrderHeader table.

&#x1F53B;&nbsp;_To Do_: For now, we assume that a Docker container with PostgreSQL and the AdventureWorks database are already running.&nbsp;&#x1F53A;

First, we connect to the database:
```{r connect to postgresql}
con <- sqlpetr::sp_get_postgres_connection(
  user = Sys.getenv("DEFAULT_POSTGRES_USER_NAME"),
  password = Sys.getenv("DEFAULT_POSTGRES_PASSWORD"),
  dbname = "adventureworks",
  port = 5432, 
  seconds_to_test = 20, 
  connection_tab = TRUE
)
```

We can list the fields in the `SalesOrderHeader` table in the `Sales` schema, using `DBI` functions:
```{r dbListFields for SalesOrderHeader}
DBI::dbExecute(con, "set search_path to sales;")
DBI::dbListFields(con, "salesorderheader")
```

The `SalesOrderHeader` has a row for each sales order, so we create a table in our R environment for that data source, ignoring the fields {`rowguid`, `modifieddate`}, which we will not be using:
```{r connect to the SalesOrderHeader table}
sales_order_header_table <- 
  dplyr::tbl(con, dbplyr::in_schema("sales", "salesorderheader")) %>% 
  select(-rowguid, -modifieddate)
names(collect(sales_order_header_table))
```

Sally asked us for the sales volume, so let's assume she wants us to count the orders by the `shipdate`, rather than the `orderdate`, since `shipdate` is when the revenue is counted:
```{r count orders by year}
# Workaround as of 2019-08-09: Must convert integer64 `shipyear` to a factor,
# due to ggplot2 defect (https://github.com/tidyverse/ggplot2/issues/2377)
sales_order_header_table %>% 
  dplyr::select(shipdate) %>% 
  collect() %>%   # collect before using tidyverse functions
  dplyr::mutate(shipyear = lubridate::year(shipdate)) %>% 
  dplyr::mutate(shipyear = forcats::as_factor(shipyear)) %>%  # workaround
  dplyr::count(shipyear) %>%  # places count in column `n`
  dplyr::arrange(shipyear) %>%
  ggplot(aes(shipyear, n)) + 
  geom_col() + 
  geom_text(aes(label = n), vjust = -0.5) + 
  ggtitle("Orders by Year") + 
  xlab("Year") + 
  ylab("Number of Orders")
```

