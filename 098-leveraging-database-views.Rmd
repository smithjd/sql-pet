# Leveraging Database Views {#chapter_leveraging-datbase-views}

> This chapter demonstrates how to:
>
>   * Investigate a database from a business perspective
>   * Dig into a single Adventureworks table containing sales data


## Setup our standard working environment

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits = 10)
sleep_default <- 1
```

Use these libraries:
```{r libraries, message=FALSE}
library(tidyverse)
library(DBI)
library(RPostgres)
library(glue)
require(knitr)
library(dbplyr)
library(sqlpetr)
library(bookdown)
library(here)
library(lubridate)
library(skimr)

library(scales) # ggplot xy scales
theme_set(theme_light())
```

Connect to `adventureworks`:
```{r, start adventureworks and connect}
sp_docker_start("adventureworks")
Sys.sleep(sleep_default)
con <- sp_get_postgres_connection(
  host = "localhost",
  port = 5432,
  user = "postgres",
  password = "postgres",
  dbname = "adventureworks",
  seconds_to_test = sleep_default, connection_tab = TRUE
)
```


## Define a database `view`

  * A `view` is query that is stored in the database 
  * Can be used to read or write to the database in a standardized and well-understood way

### Why views are useful

Reasons for views:

  * Performance: aggregation calculations done on the server.
  * Conceptual abstraction/simplification, e.g. looking at monthly subtotals, rather than having to do the aggregation in each of your   * queries.
  * Reuse: putting commonly used code in one place.
    * If you find any problems, it only needs to be fixed in one place.
    * Simplifies downstream code, so easier to read and maintain.
  * Security: a view can give access to someone who does not have access to underlying tables.
  * Standardizes data provenance 

## Existing views as a resource

  * Authoritative: writtten by a vendor or approved by a DBA
  * They are boring, but very important
  * May need verifidation or auditing -- do they meet your needs?  People may forget why a specific view exists, who is using it, etc., etc. Therefore any given view might be a forgoten vestige or part of an production data pipeline or might a priceless nugget of insight.

### How to unpack and inspect a view

Using a view to retireve data from the database will be completely standard across all flavors of SQL.

```{r}
v_salesperson_sales_by_fiscal_years_data <- 
  tbl(con, in_schema("sales","vsalespersonsalesbyfiscalyearsdata")) %>% 
  collect()

str(v_salesperson_sales_by_fiscal_years_data)

skim(v_salesperson_sales_by_fiscal_years_data)

v_salesperson_sales_by_fiscal_years_data %>% filter(salespersonid == 275)
```
Local idioms for looking at a view itself will vary.  Here is the code running the `pg_get_viewdef` function to retrieve a PostgreSQL view:

```{r}
view_definition <- dbGetQuery(con, "select 
                   pg_get_viewdef('sales.vsalespersonsalesbyfiscalyearsdata', 
                   true)")
str(view_definition)

cat(str_replace_all(view_definition$pg_get_viewdef, "\\\\\\\\n", "\\\\n")) 
  
```

Even if you don't intend to become fluent in SQL, it's useful to read as much of it as possible.  

### We recommend leverageing them

## Writing your own or modifying a view

  * What about by month? This could be motivation for creating a new view that does aggregation in the database, rather than in R.
  * See SQL code for 'vsalespersonsalesbyfiscalyearsdata'. Consider:
  * Modifying that to include quantity of sales.
  * Modifying that to include monthly totals, in addition to the yearly totals that it already has.
  * Why are 3 of the sales people from 'vsalesperson' missing in 'vsalespersonsalesbyfiscalyearsdata'?
     * Amy Alberts
     * Stephen Jiang
     * Syed Abbas
  * Making the change may not be your prerogative, but it's your responsibility to propose any reasonable changes to those who have the authority to make the make the change.

### First draft with dplyr

Save and study the SQL

t_salesperson_sales_by_fiscal_years_data 

```{r}
rm(t_salesperson_sales_by_fiscal_years_data)
t_salesperson_sales_by_fiscal_years_data <- 
  tbl(con, in_schema("sales", "salesperson")) %>% 
  select(-territoryid) %>% 
  
  left_join(tbl(con, in_schema("sales", "salesorderheader")), 
            by = c("businessentityid" = "salespersonid")) %>%
  mutate(fiscalyear = year(orderdate)) %>% 
  
  left_join(tbl(con, in_schema("sales", "salesterritory")), 
            by = c("territoryid" = "territoryid")) %>%
    rename(sales_territory = name) %>% 
  
  left_join(tbl(con, in_schema("humanresources", "employee")), 
            by = c("businessentityid" = "businessentityid")) %>%

    left_join(tbl(con, in_schema("person", "person")), 
              by = c("businessentityid" = "businessentityid")) %>%
  mutate(fullname = paste(firstname, middlename, lastname)) %>% 
  
  group_by(businessentityid, fullname, jobtitle, 
           sales_territory, fiscalyear) %>% 
  
  summarize(subtotal = sum(subtotal) ) %>% 
collect() %>% ungroup()

t_salesperson_sales_by_fiscal_years_data
skim(t_salesperson_sales_by_fiscal_years_data)

t_salesperson_sales_by_fiscal_years_data %>% 
  filter(businessentityid == 275)
```

Why 3 sales folks in vsalesperson donâ€™t show up in 2014 vsalespersonsalesbyfiscalyearsdata

Different environments / SQL dialects
