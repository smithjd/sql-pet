[
["chapter-leveraging-database-views.html", "Chapter 12 Leveraging Database Views 12.1 Setup our standard working environment 12.2 The role of database views 12.3 Reproduce the view with dplyr 12.4 Define a database view 12.5 Existing views as a resource 12.6 Writing your own or modifying a view 12.7 Save a view in the database", " Chapter 12 Leveraging Database Views This chapter demonstrates how to: Assess database views, understand their importance Unpack a database view and check its assumptions Create a database view either for personal use or for submittal to your enterprise DBA 12.1 Setup our standard working environment Use these libraries: library(tidyverse) library(DBI) library(RPostgres) library(glue) require(knitr) library(dbplyr) library(sqlpetr) library(bookdown) library(here) library(lubridate) library(skimr) library(scales) # ggplot xy scales theme_set(theme_light()) Connect to adventureworks: sp_docker_start(&quot;adventureworks&quot;) Sys.sleep(sleep_default) con &lt;- sp_get_postgres_connection( host = &quot;localhost&quot;, port = 5432, user = &quot;postgres&quot;, password = &quot;postgres&quot;, dbname = &quot;adventureworks&quot;, seconds_to_test = sleep_default, connection_tab = TRUE ) 12.2 The role of database views A database view is an SQL query that is stored in the database. Most views are used for data retrieval, since they usually denormalize the tables involved. Because they are standardized and well-understood, they can save you a lot of work. 12.2.1 Why database views are useful Database views are useful for many reasons. Authoritative: database views are typically written by the business application vendor or DBA, so they contain authoritative knowledge about the structure and intended use of the database. Performance: views are designed to gather data in an efficient way, using all the indexes in an efficient sequence and doing as much work on the database server as possible. Abstraction: views are abstractions or simplifications of complex queries that provide customary (useful) aggregations. Common examples would be monthly totals or aggregation of activity tied to one individual. Reuse: a view puts commonly used code in one place where it can be used for many purposes by many people. If there is a change or a problem found in a view, it only needs to be fixed in one place, rather than having to change many places downstream. Security: a view can give selective access to someone who does not have access to underlying tables or columns. Provenance: views standardize data provenance. For example, the AdventureWorks database all of them are named in a consistent way that suggests the underlying tables that they query. And they all start with a v. 12.2.2 Rely on and be critical of views Because they represent a conventional view of the database, a view may seem quite boring; remember why they are very important. Just because they are conventional and authorized, they may still need verification or auditing when used for a purpose other than the original intent. They can guide you toward what you need from the database but they could also mislead because they are easy to use and available. People may forget why a specific view exists and who is using it. Therefore any given view might be a forgotten vestige or part of an production data pipeline or might a priceless nugget of insight. 12.2.3 How to unpack and inspect a view From a retrieval perspective a database view is just like any other table. Using a view to retrieve data from the database will be completely standard across all flavors of SQL. (To find out what a view does behind the scenes requires that you use functions that are not standard.) v_salesperson_sales_by_fiscal_years_data &lt;- tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;)) %&gt;% collect() str(v_salesperson_sales_by_fiscal_years_data) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 48 obs. of 6 variables: ## $ salespersonid : int 275 275 275 275 276 276 276 276 277 277 ... ## $ fullname : chr &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; ... ## $ jobtitle : chr &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; ... ## $ salesterritory: chr &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; ... ## $ salestotal : num 63763 2399593 3765459 3065088 5476 ... ## $ fiscalyear : num 2011 2012 2013 2014 2011 ... skim(tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;))) Table 12.1: Data summary Name tbl(con, in_schema(&quot;sales… Number of rows 48 Number of columns 6 _______________________ Column type frequency: character 3 numeric 3 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace fullname 0 1 9 26 0 14 0 jobtitle 0 1 20 20 0 1 0 salesterritory 0 1 6 14 0 10 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist salespersonid 0 1 281.19 4.57 275.00 277.75 280.50 283.25 290 ▇▆▅▁▃ salestotal 0 1 1635214.51 1243833.87 5475.95 533827.70 1371169.72 2409498.88 4188307 ▇▇▆▃▃ fiscalyear 0 1 2012.69 1.09 2011.00 2012.00 2013.00 2014.00 2014 ▅▆▁▇▇ tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;)) %&gt;% filter(salespersonid == 275) ## # Source: lazy query [?? x 6] ## # Database: postgres [postgres@localhost:5432/adventureworks] ## salespersonid fullname jobtitle salesterritory salestotal fiscalyear ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 275 Michael G B… Sales Represe… Northeast 63763. 2011 ## 2 275 Michael G B… Sales Represe… Northeast 2399593. 2012 ## 3 275 Michael G B… Sales Represe… Northeast 3765459. 2013 ## 4 275 Michael G B… Sales Represe… Northeast 3065088. 2014 Local idioms for looking at a view itself will vary. Here is the code to retrieve a PostgreSQL view (using the pg_get_viewdef function): view_definition &lt;- dbGetQuery(con, &quot;select pg_get_viewdef(&#39;sales.vsalespersonsalesbyfiscalyearsdata&#39;, true)&quot;) str(view_definition) ## &#39;data.frame&#39;: 1 obs. of 1 variable: ## $ pg_get_viewdef: chr &quot; SELECT granular.salespersonid,\\n granular.fullname,\\n granular.jobtitle,\\n granular.salesterritory,\\n&quot;| __truncated__ cat(str_replace_all(view_definition$pg_get_viewdef, &quot;\\\\\\\\\\\\\\\\n&quot;, &quot;\\\\\\\\n&quot;)) ## SELECT granular.salespersonid, ## granular.fullname, ## granular.jobtitle, ## granular.salesterritory, ## sum(granular.subtotal) AS salestotal, ## granular.fiscalyear ## FROM ( SELECT soh.salespersonid, ## ((p.firstname::text || &#39; &#39;::text) || COALESCE(p.middlename::text || &#39; &#39;::text, &#39;&#39;::text)) || p.lastname::text AS fullname, ## e.jobtitle, ## st.name AS salesterritory, ## soh.subtotal, ## date_part(&#39;year&#39;::text, soh.orderdate + &#39;6 mons&#39;::interval) AS fiscalyear ## FROM sales.salesperson sp ## JOIN sales.salesorderheader soh ON sp.businessentityid = soh.salespersonid ## JOIN sales.salesterritory st ON sp.territoryid = st.territoryid ## JOIN humanresources.employee e ON soh.salespersonid = e.businessentityid ## JOIN person.person p ON p.businessentityid = sp.businessentityid) granular ## GROUP BY granular.salespersonid, granular.fullname, granular.jobtitle, granular.salesterritory, granular.fiscalyear; Even if you don’t intend to become fluent in SQL, it’s useful to read as much of it as possible. To understand this query, you really need to have the ERD handy. The ERD for AdventureWorks is here 12.3 Reproduce the view with dplyr Save and study the SQL. Define each table that is involved and identify the columns that will be needed from that table. sales_order_header &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesorderheader&quot;)) %&gt;% # Because we&#39;re lazy, we will keep both a crude `year` column and `orderdate` for later use mutate(sales_order_year = year(orderdate)) %&gt;% select(sales_order_year, salespersonid, subtotal, orderdate) sales_territory &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesterritory&quot;)) %&gt;% select(territoryid, territory_name = name) sales_person &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesperson&quot;)) %&gt;% select(businessentityid, territoryid) employee &lt;- tbl(con, in_schema(&quot;humanresources&quot;, &quot;employee&quot;)) %&gt;% select(businessentityid, jobtitle) person &lt;- tbl(con, in_schema(&quot;person&quot;, &quot;person&quot;)) %&gt;% mutate(fullname = paste(firstname, middlename, lastname)) %&gt;% select(businessentityid, fullname) Double check on the names that are defined in each tbl object. getnames &lt;- function(table) { {table} %&gt;% collect(n = 5) %&gt;% names() } getnames(employee) ## [1] &quot;businessentityid&quot; &quot;jobtitle&quot; getnames(person) ## [1] &quot;businessentityid&quot; &quot;fullname&quot; getnames(sales_person) ## [1] &quot;businessentityid&quot; &quot;territoryid&quot; getnames(sales_order_header) ## [1] &quot;sales_order_year&quot; &quot;salespersonid&quot; &quot;subtotal&quot; &quot;orderdate&quot; getnames(sales_territory) ## [1] &quot;territoryid&quot; &quot;territory_name&quot; 12.4 Define a database view A view is query that is stored in the database Can be used to read or write to the database in a standardized and well-understood way 12.4.1 Why views are useful Reasons for views: Performance: aggregation calculations done on the server. Conceptual abstraction/simplification, e.g. looking at monthly subtotals, rather than having to do the aggregation in each of your * queries. Reuse: putting commonly used code in one place. If you find any problems, it only needs to be fixed in one place. Simplifies downstream code, so easier to read and maintain. Security: a view can give access to someone who does not have access to underlying tables. Standardizes data provenance 12.5 Existing views as a resource Authoritative They are boring, but very important 12.5.1 How to unpack and inspect a view Using a view to retireve data from the database will be completely standard across all flavors of SQL. v_salesperson_sales_by_fiscal_years_data &lt;- tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;)) %&gt;% collect() str(v_salesperson_sales_by_fiscal_years_data) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 48 obs. of 6 variables: ## $ salespersonid : int 275 275 275 275 276 276 276 276 277 277 ... ## $ fullname : chr &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; ... ## $ jobtitle : chr &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; ... ## $ salesterritory: chr &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; ... ## $ salestotal : num 63763 2399593 3765459 3065088 5476 ... ## $ fiscalyear : num 2011 2012 2013 2014 2011 ... skim(v_salesperson_sales_by_fiscal_years_data) Table 12.2: Data summary Name v_salesperson_sales_by_fi… Number of rows 48 Number of columns 6 _______________________ Column type frequency: character 3 numeric 3 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace fullname 0 1 9 26 0 14 0 jobtitle 0 1 20 20 0 1 0 salesterritory 0 1 6 14 0 10 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist salespersonid 0 1 281.19 4.57 275.00 277.75 280.50 283.25 290 ▇▆▅▁▃ salestotal 0 1 1635214.51 1243833.87 5475.95 533827.70 1371169.72 2409498.88 4188307 ▇▇▆▃▃ fiscalyear 0 1 2012.69 1.09 2011.00 2012.00 2013.00 2014.00 2014 ▅▆▁▇▇ v_salesperson_sales_by_fiscal_years_data %&gt;% filter(salespersonid == 275) ## # A tibble: 4 x 6 ## salespersonid fullname jobtitle salesterritory salestotal fiscalyear ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 275 Michael G B… Sales Represe… Northeast 63763. 2011 ## 2 275 Michael G B… Sales Represe… Northeast 2399593. 2012 ## 3 275 Michael G B… Sales Represe… Northeast 3765459. 2013 ## 4 275 Michael G B… Sales Represe… Northeast 3065088. 2014 Local idioms for looking at a view itself will vary. Here is the code that will work for PostgreSQL: view_definition &lt;- dbGetQuery(con, &quot;select pg_get_viewdef(&#39;sales.vsalespersonsalesbyfiscalyearsdata&#39;, true)&quot;) str(view_definition) ## &#39;data.frame&#39;: 1 obs. of 1 variable: ## $ pg_get_viewdef: chr &quot; SELECT granular.salespersonid,\\n granular.fullname,\\n granular.jobtitle,\\n granular.salesterritory,\\n&quot;| __truncated__ cat(str_replace_all(view_definition$pg_get_viewdef, &quot;\\\\\\\\\\\\\\\\n&quot;, &quot;\\\\\\\\n&quot;)) ## SELECT granular.salespersonid, ## granular.fullname, ## granular.jobtitle, ## granular.salesterritory, ## sum(granular.subtotal) AS salestotal, ## granular.fiscalyear ## FROM ( SELECT soh.salespersonid, ## ((p.firstname::text || &#39; &#39;::text) || COALESCE(p.middlename::text || &#39; &#39;::text, &#39;&#39;::text)) || p.lastname::text AS fullname, ## e.jobtitle, ## st.name AS salesterritory, ## soh.subtotal, ## date_part(&#39;year&#39;::text, soh.orderdate + &#39;6 mons&#39;::interval) AS fiscalyear ## FROM sales.salesperson sp ## JOIN sales.salesorderheader soh ON sp.businessentityid = soh.salespersonid ## JOIN sales.salesterritory st ON sp.territoryid = st.territoryid ## JOIN humanresources.employee e ON soh.salespersonid = e.businessentityid ## JOIN person.person p ON p.businessentityid = sp.businessentityid) granular ## GROUP BY granular.salespersonid, granular.fullname, granular.jobtitle, granular.salesterritory, granular.fiscalyear; Even if you don’t intend to become fluent in SQL, it’s useful to read as much of it as possible. Join all of the data pertaining to a person. salesperson_info &lt;- sales_person %&gt;% left_join(employee) %&gt;% left_join(person) %&gt;% left_join(sales_territory) %&gt;% collect() ## Joining, by = &quot;businessentityid&quot;Joining, by = &quot;businessentityid&quot;Joining, by = ## &quot;territoryid&quot; str(salesperson_info) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 17 obs. of 5 variables: ## $ businessentityid: int 274 275 276 277 278 279 280 281 282 283 ... ## $ territoryid : int NA 2 4 3 6 5 1 4 6 1 ... ## $ jobtitle : chr &quot;North American Sales Manager&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; ... ## $ fullname : chr &quot;Stephen Y Jiang&quot; &quot;Michael G Blythe&quot; &quot;Linda C Mitchell&quot; &quot;Jillian Carson&quot; ... ## $ territory_name : chr NA &quot;Northeast&quot; &quot;Southwest&quot; &quot;Central&quot; ... Do a crude version with sales_order_year. All of the work can be done on the database server. sales_data_year &lt;- sales_person %&gt;% left_join(sales_order_header, by = c(&quot;businessentityid&quot; = &quot;salespersonid&quot;)) %&gt;% group_by(businessentityid, sales_order_year) %&gt;% summarize(sales_total = sum(subtotal, na.rm = TRUE)) %&gt;% collect() Lubridate makes it very easy to convert orderdate to fiscal_year. Doing that conversion interleaving dplyr and ANSI-STANDARD SQL is harder. Too lazy! sales_data_fiscal_year &lt;- sales_person %&gt;% left_join(sales_order_header, by = c(&quot;businessentityid&quot; = &quot;salespersonid&quot;)) %&gt;% collect() %&gt;% mutate(fiscal_year = year(orderdate %m+% months(6))) %&gt;% group_by(businessentityid, fiscal_year) %&gt;% summarize(sales_total = sum(subtotal, na.rm = TRUE)) %&gt;% ungroup() Put the two parts together: sales_data_fiscal_year and person_info to yeild the final query. salesperson_sales_by_fiscal_years_dplyr &lt;- sales_data_fiscal_year %&gt;% left_join(salesperson_info) %&gt;% filter(!is.na(territoryid)) ## Joining, by = &quot;businessentityid&quot; Notice that we’re droping the Sales Managers – who don’t have a territoryid. 12.5.2 Compare the two versions Use pivot_wider to make it easier to compare the native view to our dplyr version. salesperson_sales_by_fiscal_years_dplyr %&gt;% select(-jobtitle, - territoryid) %&gt;% pivot_wider(names_from = fiscal_year, values_from = sales_total) ## # A tibble: 14 x 7 ## businessentityid fullname territory_name `2011` `2012` `2013` `2014` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 275 Michael G Bly… Northeast 63763. 2399593. 3.77e6 3.07e6 ## 2 276 Linda C Mitch… Southwest 5476. 3013884. 4.06e6 3.28e6 ## 3 277 Jillian Carson Central 46696. 3496244. 3.94e6 2.58e6 ## 4 278 Garrett R Var… Canada 9109. 1254087. 1.18e6 1.17e6 ## 5 279 Tsvi Michael … Southeast 104419. 3037175. 2.16e6 1.87e6 ## 6 280 Pamela O Ansm… Northwest 24433. 1533076. 5.88e5 1.18e6 ## 7 281 Shu K Ito Southwest 59708. 1953001. 2.44e6 1.98e6 ## 8 282 José Edvaldo … Canada 106252. 2171995. 1.39e6 2.26e6 ## 9 283 David R Campb… Northwest 69473. 1291905. 1.15e6 1.22e6 ## 10 284 Tete A Mensa-… Northwest NA NA 9.59e5 1.35e6 ## 11 286 Lynn N Tsofli… Australia NA NA 1.84e5 1.24e6 ## 12 288 Rachel B Vald… Germany NA NA 3.72e5 1.46e6 ## 13 289 Jae B Pak United Kingdom NA 963345. 4.19e6 3.35e6 ## 14 290 Ranjit R Vark… France NA 360246. 1.77e6 2.38e6 v_salesperson_sales_by_fiscal_years_data %&gt;% select(-jobtitle) %&gt;% pivot_wider(names_from = fiscalyear, values_from = salestotal) ## # A tibble: 14 x 7 ## salespersonid fullname salesterritory `2011` `2012` `2013` `2014` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 275 Michael G Blythe Northeast 63763. 2399593. 3.77e6 3.07e6 ## 2 276 Linda C Mitchell Southwest 5476. 3013884. 4.06e6 3.28e6 ## 3 277 Jillian Carson Central 46696. 3496244. 3.94e6 2.58e6 ## 4 278 Garrett R Vargas Canada 9109. 1254087. 1.18e6 1.17e6 ## 5 279 Tsvi Michael Re… Southeast 104419. 3037175. 2.16e6 1.87e6 ## 6 280 Pamela O Ansman… Northwest 24433. 1533076. 5.88e5 1.18e6 ## 7 281 Shu K Ito Southwest 59708. 1953001. 2.44e6 1.98e6 ## 8 282 José Edvaldo Sa… Canada 106252. 2171995. 1.39e6 2.26e6 ## 9 283 David R Campbell Northwest 69473. 1291905. 1.15e6 1.22e6 ## 10 284 Tete A Mensa-An… Northwest NA NA 9.59e5 1.35e6 ## 11 286 Lynn N Tsoflias Australia NA NA 1.84e5 1.24e6 ## 12 288 Rachel B Valdez Germany NA NA 3.72e5 1.46e6 ## 13 289 Jae B Pak United Kingdom NA 963345. 4.19e6 3.35e6 ## 14 290 Ranjit R Varkey… France NA 360246. 1.77e6 2.38e6 The column names don’t match up, partly because we are using snake case convention for derived elements. names(salesperson_sales_by_fiscal_years_dplyr) %&gt;% sort() ## [1] &quot;businessentityid&quot; &quot;fiscal_year&quot; &quot;fullname&quot; &quot;jobtitle&quot; ## [5] &quot;sales_total&quot; &quot;territory_name&quot; &quot;territoryid&quot; names(v_salesperson_sales_by_fiscal_years_data) %&gt;% sort() ## [1] &quot;fiscalyear&quot; &quot;fullname&quot; &quot;jobtitle&quot; &quot;salespersonid&quot; ## [5] &quot;salesterritory&quot; &quot;salestotal&quot; Why 3 sales folks in vsalesperson don’t show up in 2014 vsalespersonsalesbyfiscalyearsdata Different environments / SQL dialects 12.5.3 Revise the view 12.6 Writing your own or modifying a view What about by month? This could be motivation for creating a new view that does aggregation in the database, rather than in R. See SQL code for ‘vsalespersonsalesbyfiscalyearsdata’. Consider: Modifying that to include quantity of sales. Modifying that to include monthly totals, in addition to the yearly totals that it already has. Why are 3 of the sales people from ‘vsalesperson’ missing in ‘vsalespersonsalesbyfiscalyearsdata’? Amy Alberts Stephen Jiang Syed Abbas Making the change may not be your prerogative, but it’s your responsibility to propose any reasonable changes to those who have the authority to make the make the change. Save and study the SQL 12.7 Save a view in the database "]
]
