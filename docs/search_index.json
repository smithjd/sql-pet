[
["chapter-appendix-dplyr-to-postres-translation.html", "G Appendix _ Dplyr to SQL translations G.1 Overview", " G Appendix _ Dplyr to SQL translations You may be interested in exactly how the DBI package translates R functions into their SQL quivalents â€“ and in which functions are translated and which are not. This Appendix answers those questions. It is based on the work of Dewey Dunnington ((???)(http://twitter.com/paleolimbot)) which he published here: https://apps.fishandwhistle.net/archives/1503 https://rud.is/b/2019/04/10/lost-in-sql-translation-charting-dbplyr-mapped-sql-function-support-across-all-backends/ G.1 Overview These packages are called below: library(tidyverse) library(dbplyr) library(gt) library(here) library(sqlpetr) list the DBI functions that are available: names(sql_translate_env(simulate_dbi())) ## [1] &quot;-&quot; &quot;:&quot; &quot;!&quot; ## [4] &quot;!=&quot; &quot;(&quot; &quot;[&quot; ## [7] &quot;[[&quot; &quot;{&quot; &quot;*&quot; ## [10] &quot;/&quot; &quot;&amp;&quot; &quot;&amp;&amp;&quot; ## [13] &quot;%%&quot; &quot;%&gt;%&quot; &quot;%in%&quot; ## [16] &quot;^&quot; &quot;+&quot; &quot;&lt;&quot; ## [19] &quot;&lt;=&quot; &quot;==&quot; &quot;&gt;&quot; ## [22] &quot;&gt;=&quot; &quot;|&quot; &quot;||&quot; ## [25] &quot;$&quot; &quot;abs&quot; &quot;acos&quot; ## [28] &quot;as_date&quot; &quot;as_datetime&quot; &quot;as.character&quot; ## [31] &quot;as.Date&quot; &quot;as.double&quot; &quot;as.integer&quot; ## [34] &quot;as.integer64&quot; &quot;as.logical&quot; &quot;as.numeric&quot; ## [37] &quot;as.POSIXct&quot; &quot;asin&quot; &quot;atan&quot; ## [40] &quot;atan2&quot; &quot;between&quot; &quot;bitwAnd&quot; ## [43] &quot;bitwNot&quot; &quot;bitwOr&quot; &quot;bitwShiftL&quot; ## [46] &quot;bitwShiftR&quot; &quot;bitwXor&quot; &quot;c&quot; ## [49] &quot;case_when&quot; &quot;ceil&quot; &quot;ceiling&quot; ## [52] &quot;coalesce&quot; &quot;cos&quot; &quot;cosh&quot; ## [55] &quot;cot&quot; &quot;coth&quot; &quot;day&quot; ## [58] &quot;desc&quot; &quot;exp&quot; &quot;floor&quot; ## [61] &quot;hour&quot; &quot;if&quot; &quot;if_else&quot; ## [64] &quot;ifelse&quot; &quot;is.na&quot; &quot;is.null&quot; ## [67] &quot;log&quot; &quot;log10&quot; &quot;mday&quot; ## [70] &quot;minute&quot; &quot;month&quot; &quot;na_if&quot; ## [73] &quot;nchar&quot; &quot;now&quot; &quot;paste&quot; ## [76] &quot;paste0&quot; &quot;pmax&quot; &quot;pmin&quot; ## [79] &quot;qday&quot; &quot;round&quot; &quot;second&quot; ## [82] &quot;sign&quot; &quot;sin&quot; &quot;sinh&quot; ## [85] &quot;sql&quot; &quot;sqrt&quot; &quot;str_c&quot; ## [88] &quot;str_conv&quot; &quot;str_count&quot; &quot;str_detect&quot; ## [91] &quot;str_dup&quot; &quot;str_extract&quot; &quot;str_extract_all&quot; ## [94] &quot;str_flatten&quot; &quot;str_glue&quot; &quot;str_glue_data&quot; ## [97] &quot;str_interp&quot; &quot;str_length&quot; &quot;str_locate&quot; ## [100] &quot;str_locate_all&quot; &quot;str_match&quot; &quot;str_match_all&quot; ## [103] &quot;str_order&quot; &quot;str_pad&quot; &quot;str_remove&quot; ## [106] &quot;str_remove_all&quot; &quot;str_replace&quot; &quot;str_replace_all&quot; ## [109] &quot;str_replace_na&quot; &quot;str_sort&quot; &quot;str_split&quot; ## [112] &quot;str_split_fixed&quot; &quot;str_squish&quot; &quot;str_sub&quot; ## [115] &quot;str_subset&quot; &quot;str_to_lower&quot; &quot;str_to_title&quot; ## [118] &quot;str_to_upper&quot; &quot;str_trim&quot; &quot;str_trunc&quot; ## [121] &quot;str_view&quot; &quot;str_view_all&quot; &quot;str_which&quot; ## [124] &quot;str_wrap&quot; &quot;substr&quot; &quot;switch&quot; ## [127] &quot;tan&quot; &quot;tanh&quot; &quot;today&quot; ## [130] &quot;tolower&quot; &quot;toupper&quot; &quot;trimws&quot; ## [133] &quot;wday&quot; &quot;xor&quot; &quot;yday&quot; ## [136] &quot;year&quot; &quot;cume_dist&quot; &quot;cummax&quot; ## [139] &quot;cummean&quot; &quot;cummin&quot; &quot;cumsum&quot; ## [142] &quot;dense_rank&quot; &quot;first&quot; &quot;lag&quot; ## [145] &quot;last&quot; &quot;lead&quot; &quot;max&quot; ## [148] &quot;mean&quot; &quot;median&quot; &quot;min&quot; ## [151] &quot;min_rank&quot; &quot;n&quot; &quot;n_distinct&quot; ## [154] &quot;nth&quot; &quot;ntile&quot; &quot;order_by&quot; ## [157] &quot;percent_rank&quot; &quot;quantile&quot; &quot;rank&quot; ## [160] &quot;row_number&quot; &quot;sum&quot; &quot;var&quot; ## [163] &quot;cume_dist&quot; &quot;cummax&quot; &quot;cummean&quot; ## [166] &quot;cummin&quot; &quot;cumsum&quot; &quot;dense_rank&quot; ## [169] &quot;first&quot; &quot;lag&quot; &quot;last&quot; ## [172] &quot;lead&quot; &quot;max&quot; &quot;mean&quot; ## [175] &quot;median&quot; &quot;min&quot; &quot;min_rank&quot; ## [178] &quot;n&quot; &quot;n_distinct&quot; &quot;nth&quot; ## [181] &quot;ntile&quot; &quot;order_by&quot; &quot;percent_rank&quot; ## [184] &quot;quantile&quot; &quot;rank&quot; &quot;row_number&quot; ## [187] &quot;sum&quot; &quot;var&quot; sql_translate_env(simulate_dbi()) ## &lt;sql_variant&gt; ## scalar: -, :, !, !=, (, [, [[, {, *, /, &amp;, &amp;&amp;, %%, %&gt;%, %in%, ## scalar: ^, +, &lt;, &lt;=, ==, &gt;, &gt;=, |, ||, $, abs, acos, as_date, ## scalar: as_datetime, as.character, as.Date, as.double, ## scalar: as.integer, as.integer64, as.logical, as.numeric, ## scalar: as.POSIXct, asin, atan, atan2, between, bitwAnd, ## scalar: bitwNot, bitwOr, bitwShiftL, bitwShiftR, bitwXor, c, ## scalar: case_when, ceil, ceiling, coalesce, cos, cosh, cot, ## scalar: coth, day, desc, exp, floor, hour, if, if_else, ifelse, ## scalar: is.na, is.null, log, log10, mday, minute, month, na_if, ## scalar: nchar, now, paste, paste0, pmax, pmin, qday, round, ## scalar: second, sign, sin, sinh, sql, sqrt, str_c, str_conv, ## scalar: str_count, str_detect, str_dup, str_extract, ## scalar: str_extract_all, str_flatten, str_glue, str_glue_data, ## scalar: str_interp, str_length, str_locate, str_locate_all, ## scalar: str_match, str_match_all, str_order, str_pad, ## scalar: str_remove, str_remove_all, str_replace, ## scalar: str_replace_all, str_replace_na, str_sort, str_split, ## scalar: str_split_fixed, str_squish, str_sub, str_subset, ## scalar: str_to_lower, str_to_title, str_to_upper, str_trim, ## scalar: str_trunc, str_view, str_view_all, str_which, str_wrap, ## scalar: substr, switch, tan, tanh, today, tolower, toupper, ## scalar: trimws, wday, xor, yday, year ## aggregate: cume_dist, cummax, cummean, cummin, cumsum, dense_rank, ## aggregate: first, lag, last, lead, max, mean, median, min, ## aggregate: min_rank, n, n_distinct, nth, ntile, order_by, ## aggregate: percent_rank, quantile, rank, row_number, sum, var ## window: cume_dist, cummax, cummean, cummin, cumsum, dense_rank, ## window: first, lag, last, lead, max, mean, median, min, ## window: min_rank, n, n_distinct, nth, ntile, order_by, ## window: percent_rank, quantile, rank, row_number, sum, var source(here(&quot;book-src&quot;, &quot;dbplyr-sql-function-translation.R&quot;)) Each of the following dbplyr back ends may have a slightly different translation: translations %&gt;% filter(!is.na(sql)) %&gt;% count(variant) ## # A tibble: 11 x 2 ## variant n ## &lt;chr&gt; &lt;int&gt; ## 1 access 193 ## 2 dbi 183 ## 3 hive 156 ## 4 impala 190 ## 5 mssql 194 ## 6 mysql 194 ## 7 odbc 186 ## 8 oracle 184 ## 9 postgres 204 ## 10 sqlite 134 ## 11 teradata 196 Only one postgres translation produces an output: psql &lt;- translations %&gt;% filter(!is.na(sql), variant == &quot;postgres&quot;) %&gt;% select(r, n_args, sql) %&gt;% arrange(r) sp_print_df(head(psql, n = 40)) "]
]
