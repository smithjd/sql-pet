[
["chapter-leveraging-database-views.html", "12 Leveraging Database Views 12.1 Setup our standard working environment 12.2 The role of database views 12.3 Unpacking the elements of a view Tidyverse 12.4 Compare the official from a view and the dplyr output 12.5 Revise the view 12.6 Save a view in the database", " 12 Leveraging Database Views This chapter demonstrates how to: Understand database views and their uses Unpack a database view to see what it’s doing Reproduce a database view with dplyr code Write an alternative to a view that provides more details Create a database view either for personal use or for submittal to your enterprise DBA 12.1 Setup our standard working environment Use these libraries: library(tidyverse) library(DBI) library(RPostgres) library(connections) library(glue) require(knitr) library(dbplyr) library(sqlpetr) library(bookdown) library(here) library(lubridate) library(skimr) # library(DiagrammeR) library(scales) # ggplot xy scales theme_set(theme_light()) Connect to adventureworks: sp_docker_start(&quot;adventureworks&quot;) Sys.sleep(sleep_default) con &lt;- connection_open( # use in an interactive session # con &lt;- dbConnect( # use in other settings RPostgres::Postgres(), # without the following (and preceding) lines, # bigint become int64 which is a problem for ggplot bigint = &quot;integer&quot;, host = &quot;localhost&quot;, port = 5432, user = &quot;postgres&quot;, password = &quot;postgres&quot;, dbname = &quot;adventureworks&quot; ) dbExecute(con, &quot;set search_path to sales;&quot;) ## [1] 0 12.2 The role of database views A database view is an SQL query that is stored in the database. Most views are used for data retrieval, since they usually denormalize the tables involved. Because they are standardized and well-understood, they can save you a lot of work. 12.2.1 Why database views are useful Database views are useful for many reasons. Authoritative: database views are typically written by the business application vendor or DBA, so they contain authoritative knowledge about the structure and intended use of the database. Performance: views are designed to gather data in an efficient way, using all the indexes in an efficient sequence and doing as much work on the database server as possible. Abstraction: views are abstractions or simplifications of complex queries that provide customary (useful) aggregations. Common examples would be monthly totals or aggregation of activity tied to one individual. Reuse: a view puts commonly used code in one place where it can be used for many purposes by many people. If there is a change or a problem found in a view, it only needs to be fixed in one place, rather than having to change many places downstream. Security: a view can give selective access to someone who does not have access to underlying tables or columns. Provenance: views standardize data provenance. For example, the AdventureWorks database all of them are named in a consistent way that suggests the underlying tables that they query. And they all start with a v. 12.2.2 Rely on and be critical of views Because they represent a conventional view of the database, a view may seem quite boring; remember why they are very important. Just because they are conventional and authorized, they may still need verification or auditing when used for a purpose other than the original intent. They can guide you toward what you need from the database but they could also mislead because they are easy to use and available. People may forget why a specific view exists and who is using it. Therefore any given view might be a forgotten vestige or part of a production data pipeline or a priceless nugget of insight. How can you tell? Consider the owner and schema, whether it’s a materialized index view or not, if it has a trigger and try to deduce the intentionality behind the view. 12.3 Unpacking the elements of a view Tidyverse Since a view is just like an ordinary table, many of the tools we’ve become familiar with work the same. The simplest way of getting a list of columns in a view is the same as it is for a regular table: dbListFields(con, &quot;vsalespersonsalesbyfiscalyearsdata&quot;) ## [1] &quot;salespersonid&quot; &quot;fullname&quot; &quot;jobtitle&quot; &quot;salesterritory&quot; ## [5] &quot;salestotal&quot; &quot;fiscalyear&quot; 12.3.1 Use a view just like any other table From a retrieval perspective a database view is just like any other table. Using a view to retrieve data from the database will be completely standard across all flavors of SQL. (To find out what a view does behind the scenes requires that you use functions that are not standard.) v_salesperson_sales_by_fiscal_years_data &lt;- tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;)) %&gt;% collect() str(v_salesperson_sales_by_fiscal_years_data) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 48 obs. of 6 variables: ## $ salespersonid : int 275 275 275 275 276 276 276 276 277 277 ... ## $ fullname : chr &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; &quot;Michael G Blythe&quot; ... ## $ jobtitle : chr &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; ... ## $ salesterritory: chr &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; &quot;Northeast&quot; ... ## $ salestotal : num 63763 2399593 3765459 3065088 5476 ... ## $ fiscalyear : num 2011 2012 2013 2014 2011 ... tbl(con, in_schema(&quot;sales&quot;,&quot;vsalespersonsalesbyfiscalyearsdata&quot;)) %&gt;% filter(salespersonid == 275) %&gt;% collect() ## # A tibble: 4 x 6 ## salespersonid fullname jobtitle salesterritory salestotal fiscalyear ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 275 Michael G B… Sales Represe… Northeast 63763. 2011 ## 2 275 Michael G B… Sales Represe… Northeast 2399593. 2012 ## 3 275 Michael G B… Sales Represe… Northeast 3765459. 2013 ## 4 275 Michael G B… Sales Represe… Northeast 3065088. 2014 view replication is a big PITA. do it to understand the view mechanics and do that to extend or modify the view. at the end: share with others via the DBA. Start with what you need, then “look up” with other tables. Within the constraints of foreign keys. Index considerations. 12.3.2 SQL source code Database-specific idioms for looking at a view itself will vary. Here is the code to retrieve a PostgreSQL view (using the pg_get_viewdef function): view_definition &lt;- dbGetQuery(con, &quot;select pg_get_viewdef(&#39;sales.vsalespersonsalesbyfiscalyearsdata&#39;, true)&quot;) The PostgreSQL pg_get_viewdef function returns a data frame with one column named pg_get_viewdef and one row. To properly view its contents, the \\n character strings need to be turned into new-lines. cat(str_replace_all(view_definition$pg_get_viewdef, &quot;\\\\\\\\\\\\\\\\n&quot;, &quot;\\\\\\\\n&quot;)) ## SELECT granular.salespersonid, ## granular.fullname, ## granular.jobtitle, ## granular.salesterritory, ## sum(granular.subtotal) AS salestotal, ## granular.fiscalyear ## FROM ( SELECT soh.salespersonid, ## ((p.firstname::text || &#39; &#39;::text) || COALESCE(p.middlename::text || &#39; &#39;::text, &#39;&#39;::text)) || p.lastname::text AS fullname, ## e.jobtitle, ## st.name AS salesterritory, ## soh.subtotal, ## date_part(&#39;year&#39;::text, soh.orderdate + &#39;6 mons&#39;::interval) AS fiscalyear ## FROM salesperson sp ## JOIN salesorderheader soh ON sp.businessentityid = soh.salespersonid ## JOIN salesterritory st ON sp.territoryid = st.territoryid ## JOIN humanresources.employee e ON soh.salespersonid = e.businessentityid ## JOIN person.person p ON p.businessentityid = sp.businessentityid) granular ## GROUP BY granular.salespersonid, granular.fullname, granular.jobtitle, granular.salesterritory, granular.fiscalyear; Even if you don’t intend to become completely fluent in SQL, it’s useful to study as much of it as possible. Studying the SQL in a view is particularly useful to: Test your understanding of the database structure, elements, and usage Extend what’s already been done to extract useful data from the database 12.3.3 The ERD as context for SQL code A database Entity Relationship Diagram (ERD) is very helpful in making sense of the SQL in a view. The ERD for AdventureWorks is here. Save and study the SQL. 12.3.4 Tables and columns use tools like PostgreSQL pg_modeler to get an ERD. It can be helpful to actually mark up the ERD to identify the specific tables that are involved in the view you are going to reproduce. The sales.vsalespersonsalesbyfiscalyearsdata view joins data from five different tables Define each table that is involved and identify the columns that will be needed from that table. The tables that are involved are: sales_order_header sales_territory sales_person employee person Select the columns and do any necessary changes or renaming. Avoid dbplyr default joins by not including rowguid and ModifiedDate columns, which appear in almost all AdventureWorks tables. Also, we follow the convention that any column that we change or create on the fly uses a snake case naming convention. sales_order_header &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesorderheader&quot;)) %&gt;% select(orderdate, salespersonid, subtotal) sales_territory &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesterritory&quot;)) %&gt;% select(territoryid, territory_name = name) sales_person &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesperson&quot;)) %&gt;% select(businessentityid, territoryid) employee &lt;- tbl(con, in_schema(&quot;humanresources&quot;, &quot;employee&quot;)) %&gt;% select(businessentityid, jobtitle) person &lt;- tbl(con, in_schema(&quot;person&quot;, &quot;person&quot;)) %&gt;% mutate(full_name = paste(firstname, middlename, lastname)) %&gt;% select(businessentityid, full_name) Double check on the names that are defined in each tbl object. First define a function to show the names of columns you will retrieve. getnames &lt;- function(table) { {table} %&gt;% collect(n = 5) %&gt;% names() } Verify the names selected: getnames(sales_order_header) ## [1] &quot;orderdate&quot; &quot;salespersonid&quot; &quot;subtotal&quot; getnames(sales_territory) ## [1] &quot;territoryid&quot; &quot;territory_name&quot; getnames(sales_person) ## [1] &quot;businessentityid&quot; &quot;territoryid&quot; getnames(employee) ## [1] &quot;businessentityid&quot; &quot;jobtitle&quot; getnames(person) ## [1] &quot;businessentityid&quot; &quot;full_name&quot; 12.3.5 Join the tables together Join all of the data pertaining to a person. Notice that since all of these 4 tables contain businessentityid, dplyr will join them all on that common column automatically. salesperson_info &lt;- sales_person %&gt;% left_join(employee) %&gt;% left_join(person) %&gt;% left_join(sales_territory) %&gt;% collect() ## Joining, by = &quot;businessentityid&quot;Joining, by = &quot;businessentityid&quot;Joining, by = ## &quot;territoryid&quot; str(salesperson_info) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 17 obs. of 5 variables: ## $ businessentityid: int 274 275 276 277 278 279 280 281 282 283 ... ## $ territoryid : int NA 2 4 3 6 5 1 4 6 1 ... ## $ jobtitle : chr &quot;North American Sales Manager&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; &quot;Sales Representative&quot; ... ## $ full_name : chr &quot;Stephen Y Jiang&quot; &quot;Michael G Blythe&quot; &quot;Linda C Mitchell&quot; &quot;Jillian Carson&quot; ... ## $ territory_name : chr NA &quot;Northeast&quot; &quot;Southwest&quot; &quot;Central&quot; ... Discuss: date_part('year'::text, soh.orderdate + '6 mons'::interval) AS fiscalyear Do a crude version with orderdate. All of the work can be done on the database server. sales_data_year &lt;- sales_person %&gt;% left_join(sales_order_header, by = c(&quot;businessentityid&quot; = &quot;salespersonid&quot;)) %&gt;% group_by(businessentityid, orderdate) %&gt;% summarize(sales_total = sum(subtotal, na.rm = TRUE)) %&gt;% collect() Lubridate makes it very easy to convert orderdate to fiscal_year. Doing that conversion interleaving dplyr and ANSI-STANDARD SQL is harder. Too lazy! Therefore we just pull the data from the server after the left_join and do the rest of the job on the R side. ** notice that the merge is happening on the R side. there would be a modification to make it all (or as much as possible) happen on the server side.** Using this function as a model: dbExecute( con, &quot;CREATE OR REPLACE FUNCTION so_adj_date(so_date timestamp, ONLINE_ORDER boolean) RETURNS timestamp AS $$ BEGIN IF (ONLINE_ORDER) THEN RETURN (SELECT so_date); ELSE RETURN(SELECT CASE WHEN EXTRACT(DAY FROM so_date) = 1 THEN so_date - &#39;1 day&#39;::interval ELSE so_date END ); END IF; END; $$ LANGUAGE PLPGSQL; &quot; ) Trying to create a function that returns fiscal year on the server side. dbExecute( con, &quot;CREATE OR REPLACE FUNCTION so_calc_fy(orderdate timestamp) RETURNS orderdate AS $$ RETURN(date_part(&#39;year&#39;::text, orderdate + &#39;6 mons&#39;::interval)) $$ LANGUAGE PLPGSQL; &quot; ) sales_data_fiscal_year &lt;- sales_person %&gt;% left_join(sales_order_header, by = c(&quot;businessentityid&quot; = &quot;salespersonid&quot;)) %&gt;% # mutate(fiscal_year = year(orderdate %m+% months(6))) %&gt;% group_by(businessentityid, orderdate) %&gt;% summarize(sales_total = sum(subtotal, na.rm = TRUE)) %&gt;% mutate( orderdate = as.Date(orderdate), day = day(orderdate) ) %&gt;% collect() %&gt;% ungroup() %&gt;% mutate( adjusted_orderdate = case_when( day == 1L ~ orderdate -1, TRUE ~ orderdate ), year_month = floor_date(adjusted_orderdate, &quot;month&quot;) ) str(sales_data_fiscal_year) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 468 obs. of 6 variables: ## $ businessentityid : int 283 288 282 278 276 283 279 279 280 279 ... ## $ orderdate : Date, format: &quot;2012-03-30&quot; &quot;2014-02-28&quot; ... ## $ sales_total : num 115902 765 110014 196793 497156 ... ## $ day : num 30 28 1 1 31 31 30 30 30 30 ... ## $ adjusted_orderdate: Date, format: &quot;2012-03-30&quot; &quot;2014-02-28&quot; ... ## $ year_month : Date, format: &quot;2012-03-01&quot; &quot;2014-02-01&quot; ... # View(sales_data_fiscal_year) Put the two parts together: sales_data_fiscal_year and person_info to yield the final query. salesperson_sales_by_fiscal_years_dplyr &lt;- sales_data_fiscal_year %&gt;% left_join(salesperson_info) %&gt;% filter(!is.na(territoryid)) ## Joining, by = &quot;businessentityid&quot; Notice that we’re dropping the Sales Managers – who don’t have a territoryid. 12.4 Compare the official from a view and the dplyr output Use pivot_wider to make it easier to compare the native view to our dplyr version. salesperson_sales_by_fiscal_years_dplyr %&gt;% mutate(calendar_year = year(adjusted_orderdate)) %&gt;% #names() group_by(full_name, territory_name, calendar_year) %&gt;% summarize(sales_total = sum(sales_total)) %&gt;% # select(full_name, territory_name, calendar_year, sales_total) %&gt;% ungroup() %&gt;% pivot_wider(names_from = calendar_year, values_from = sales_total, values_fill = list(sales_total = 0)) %&gt;% arrange(territory_name, full_name) ## # A tibble: 14 x 6 ## full_name territory_name `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lynn N Tsoflias Australia 0 0 836055. 585756. ## 2 Garrett R Vargas Canada 613330. 1170331. 1389837. 435949. ## 3 José Edvaldo Saraiva Canada 1338400. 1672323. 1870884. 1044811. ## 4 Jillian Carson Central 1631265. 3997669. 3396776. 1040093. ## 5 Ranjit R Varkey Chudukatil France 0 996292. 2646078. 867519. ## 6 Rachel B Valdez Germany 0 0 1245459. 581608. ## 7 Michael G Blythe Northeast 1031655. 3219626. 3985375. 1057247. ## 8 David R Campbell Northwest 726049. 1162008. 1351422. 490466. ## 9 Pamela O Ansman-Wolfe Northwest 838589. 1018161. 963421. 504932. ## 10 Tete A Mensa-Annan Northwest 0 441640. 1269909. 600997. ## 11 Tsvi Michael Reiter Southeast 1833198. 2362528. 2188083. 787204. ## 12 Linda C Mitchell Southwest 1530233. 3454391. 4111295. 1271089. ## 13 Shu K Ito Southwest 1046490. 2215318. 2387256. 777942. ## 14 Jae B Pak United Kingdom 0 3014278. 4106064. 1382997. # pivot_wider(names_from = fiscal_year, values_from = sales_total) v_salesperson_sales_by_fiscal_years_data %&gt;% # names() select(-jobtitle, -salespersonid) %&gt;% pivot_wider(names_from = fiscalyear, values_from = salestotal, values_fill = list(salestotal = 0)) %&gt;% arrange(salesterritory, fullname) ## # A tibble: 14 x 6 ## fullname salesterritory `2011` `2012` `2013` `2014` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lynn N Tsoflias Australia 0 0 184106. 1237705. ## 2 Garrett R Vargas Canada 9109. 1254087. 1179531. 1166720. ## 3 José Edvaldo Saraiva Canada 106252. 2171995. 1388793. 2259378. ## 4 Jillian Carson Central 46696. 3496244. 3940665. 2582199. ## 5 Ranjit R Varkey Chudukatil France 0 360246. 1770367. 2379277. ## 6 Rachel B Valdez Germany 0 0 371973. 1455094. ## 7 Michael G Blythe Northeast 63763. 2399593. 3765459. 3065088. ## 8 David R Campbell Northwest 69473. 1291905. 1151081. 1217487. ## 9 Pamela O Ansman-Wolfe Northwest 24433. 1533076. 587779. 1179815. ## 10 Tete A Mensa-Annan Northwest 0 0 959000. 1353546. ## 11 Tsvi Michael Reiter Southeast 104419. 3037175. 2159685. 1869733. ## 12 Linda C Mitchell Southwest 5476. 3013884. 4064078. 3283569. ## 13 Shu K Ito Southwest 59708. 1953001. 2439216. 1975080. ## 14 Jae B Pak United Kingdom 0 963345. 4188307. 3351687. The column names don’t match up, partly because we are using snake case convention for derived elements. names(salesperson_sales_by_fiscal_years_dplyr) %&gt;% sort() ## [1] &quot;adjusted_orderdate&quot; &quot;businessentityid&quot; &quot;day&quot; ## [4] &quot;full_name&quot; &quot;jobtitle&quot; &quot;orderdate&quot; ## [7] &quot;sales_total&quot; &quot;territory_name&quot; &quot;territoryid&quot; ## [10] &quot;year_month&quot; names(v_salesperson_sales_by_fiscal_years_data) %&gt;% sort() ## [1] &quot;fiscalyear&quot; &quot;fullname&quot; &quot;jobtitle&quot; &quot;salespersonid&quot; ## [5] &quot;salesterritory&quot; &quot;salestotal&quot; the following doesn’t quite work yet. The idea is to do as much work on the server as possible to correct the data entry date. sales_order_header_fy &lt;- tbl(con, in_schema(&quot;sales&quot;, &quot;salesorderheader&quot;)) %&gt;% mutate(orderdate = as.Date(orderdate), sales_order_year = year(orderdate), sales_order_month = month(orderdate), sales_order_day = as.numeric(day(orderdate)) ) %&gt;% select(sales_order_year, sales_order_month, sales_order_day, salespersonid, subtotal, orderdate) %&gt;% group_by(sales_order_year, sales_order_month, sales_order_day, salespersonid) %&gt;% summarize(subtotal = sum(subtotal, na.rm = TRUE)) %&gt;% collect() %&gt;% # show_query %&gt;% mutate( sales_order_day_adj = ifelse( sales_order_day == 1, sales_order_day - 1, sales_order_day ) ) %&gt;% ungroup() # , # View(sales_order_header_fy) str(sales_order_header_fy) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 1592 obs. of 6 variables: ## $ sales_order_year : num 2014 2013 2013 2014 2014 ... ## $ sales_order_month : num 6 11 6 2 2 7 5 3 1 2 ... ## $ sales_order_day : num 8 17 25 25 14 20 13 30 4 28 ... ## $ salespersonid : int NA NA NA NA NA NA NA 281 NA 283 ... ## $ subtotal : num 1046 63751 20063 45560 46304 ... ## $ sales_order_day_adj: num 8 17 25 25 14 20 13 30 4 28 ... Why 3 sales folks in vsalesperson don’t show up in 2014 vsalespersonsalesbyfiscalyearsdata Different environments / SQL dialects 12.5 Revise the view repeat the function creation strategy from 083 – correct the date extract the fiscal year What about by month? This could be motivation for creating a new view that does aggregation in the database, rather than in R. See SQL code for ‘vsalespersonsalesbyfiscalyearsdata’. Consider: Modifying that to include quantity of sales. Modifying that to include monthly totals, in addition to the yearly totals that it already has. Why are 3 of the sales people from ‘vsalesperson’ missing in ‘vsalespersonsalesbyfiscalyearsdata’? Amy Alberts Stephen Jiang Syed Abbas Making the change may not be your prerogative, but it’s your responsibility to propose any reasonable changes to those who have the authority to make the make the change. 12.6 Save a view in the database connection_close(con) # Use in an interactive setting # dbDisconnect(con) # Use in non-interactive setting "]
]
